# Git

## Git을 왜 사용해야 할까?

### 기록(버전) 관리를 위해서

- 작업 내용을 수정/추가/삭제를 해야할 경우 이전 기록(버전) 관리가 필요함.
- 이전 기록(버전)을 체계적으로 관리할 수 있게 도와주는 버전 관리 시스템

## Git이란?

파일의 변경 사항을 추적하고 여러 사용자 간에 해당 파일들의 작업을 조율하기 위한 분산 버전 관리 시스템

### 1. 파일의 변경 사항을 추적

- Git을 이용하면 한 파일 내에서 일어난 변화를 모두 Git이라는 시스템을 이용해 기록할 수 있다.
- 정확히 언제 파일을 수정했는지, 그때 파일 내에서 어떠한 변화가 있었는지 Git이 대신 기록해주기 때문에 특정 시점에서 이전 내용을 언제든지 다시 꺼내볼 수 있다.
- 기록은 로그 형식으로 관리되기 때문에 파일을 저장하지 않아도 된다.
- 이러한 파일 내 변화를 기록하고 찾아주는 것을 파일의 변경 사항들을 추적한다고 부른다.

### 2. 여러 사용자 간에 해당 파일들의 작업들을 조율

- Git을 이용할때 Github같은 원격(remote)저장소를 활용한다.
- 내 컴퓨터(local), 인터넷 상 저장소(remote)
- 한 파일을 Github에 올려놓으면 동시에 여러 사용자가 접근 가능하다.
- 여러 사용자 간에 해당 파일들의 작업들을 조율한다는 것은 여러 사용자가 특정 내용에 대해 접근이 가능하고 공동으로 작업할 수 있다는 것을 의미함

### 3. 분산 버전 관리 시스템

- Division VCS : 중앙에서 관리하고 있던 모든 이력을 가진 저장소 전체를 복사하여 사용자의 컴퓨터로 가져와 사용함.
- 여러명이 한 파일(또는 폴더)에 접근해 개별적으로 작업하고, 작업 결과를 기록으로서 반영하는 시스템

## 내 파일이 관리되는 방법

### repository(레포)

- 파일 하나가 아니라 여러 파일도 관리할 수 있는 저장소(폴더의 개념)
- local repository(로컬 저장소) - 내 컴퓨터
- remote repository(원격 저장소) - Github

### 1. Working Directory

- 내가 현재 작업하는 폴더.
- 대부분의 파일들의 변경사항이 추적됨.
- 보안 문제로 원격 레포에 올리지 못하는 토큰, 서버의 BaseURL 등은 추적을 하지 않음. (#.gitignore #파일안에 해당 파일을 모두 넣어서 관리함.)

### 2. Staging Area

- staged 파일들이 존재함. (commit 대기중인 파일들)

추적되는 파일들의 상태

1. unmodified: 변경 없음.
2. modified: 변경됨.
3. staged: 스테이지됨. (commit 대기)

- add
  - 변경된(modified)파일들 중 commit 하고 싶은 파일만 stage 하는 것.
- commit
  - 세이브 포인트 (파일 변경사항 기록)

### 3. Local Repository

- commit을 통한 파일의 변경사항을 기록하는 곳
- 이후 Remote Repository로 반영하기 위해서 push라는 명령어를 사용함.

## Git 사용법

### 1. 원격 레포 생성하고 로컬 레포와 연결하기

- Github에서 원격 레포 생성
- 내 컴퓨터의 원하는 폴더에서 터미널을 열고 git clone

### 2. .gitignore로 파일 추적되지 않게 관리하기

- 보안이 중요한 파일 생성
- .gitignore 파일 생성
- .gitignore 파일 안에 보안이 중요한 파일 이름 작성
  - temp1.txt
  - .txt → .txt이 확장자인 파일 모두 ignore
  - temp1 → temp1이 이름인 파일 모두 ignore

### 3. add, commit, push로 내 파일 추적 상태 관리하기

- add

  - 모든 파일을 한번에 staged 상태로 변경하는 방법
    - git add .
  - 특정 파일만 staged 상태로 변경하는 방법
    - git add (파일 이름)

- commit

  - staged 파일의 변경사항을 로컬 레포에 반영
    - git commit -m “(커밋 메시지)”

- push
  - 로컬 레포에 반영된 내용을 원격 레포에 반영
    - git push origin (브랜치 이름)

### 4. 내 파일 상태 확인하기

- git status

## 브랜치(branch)란?

### 1. 내가 작업하는 독립적인 영역

개발자들이 동시에 작업하지만 서로에게 영향을 끼치지 않도록 처리해 주는 것

- 작업이 끝난 후 브랜치를 합지면 원래 브랜치와 합쳐진 브랜치의 내용을 알 수 있음

### 2. 브랜치 만들고 전환하기

- 브랜치 만들기
  - git branch (브랜치 이름)
- 브랜치 전환하기
  - git switch (브랜치 이름)

### 3. 브랜치 merge 하기 (병합하기)

- 브랜치 병합하기
  - git merge (병합할 브랜치)
- 협업 시에는 보통 merge를 사용해 병합하지 않음. (충돌 위험때문에)
  - 보통 Pull Request를 작성해 병합함 → 2주차에 알아볼 예정

## 커밋 기록 확인하기

### 1. git log 조회하기

- git log
  - 커밋의 기록을 살펴보는것을 로그를 살펴본다 라고 표현함.
  - git log를 통해 커밋 로그를 살펴볼 수 있음.

### 커밋의 구성

- 커밋 해시: commit 691ceb4268ec2c5b2d1afd79dd41f5783dcfac46
  - (**HEAD -> main**, **origin/main**, **origin/HEAD**)
- 커밋 생성자: youz2me <kynhun20@gachon.ac.kr>
- 커밋 일시: Sun Sep 22 18:34:03 2024 +0900
- 커밋 메시지: fix: validate 명령어 파라미터 안들어가게 수정

### 2. 내 브랜치의 가장 최신 주소 : HEAD

- 모든 브랜치에는 HEAD 값이 존재하며, 이는 현재 브랜치의 최신 커밋을 참조하는 값이다.
- 브랜치를 새로 생성하면 이전 브랜치의 commit 기록을 모두 가져온다.

- (HEAD -> tardy) 은 현재 HEAD는 tardy 브랜치의 feat: 지각 현황 기능 구현 커밋을 가리키고 있다는 것을 의미
- origin/main은 feat: 약속 정보 기능 구현 커밋에 위치

## Issue와 Pull Requset는 무엇일까?

### 1. ISSUE

- 나의 작은 목표를 설정해 놓은것
- 프로젝트 협업 시 동일한 부분을 작업하면 작업 병합 시 충돌이 일어나기 때문에 기능별로 브랜치를 나눈다 (Git-flow방식)
- main 브랜치에서 기능 브랜치를 나누기 전 팀원들과 프로젝트의 작업 진행 현황과 기능구현, 버그 수정, 리팩토링 등을 공유하기 위해 Issue를 생성한다.
- Github 레포에서 New Issue를 클릭하면 작성할 수 있다.

이슈는 크게 제목, 내용, Assignees/Labels, Projects, Milestone, Development로 나눌 수 있다. (팀 내 컨벤션(규칙)에 따라 달라진다.)

- 제목
  - 보통 작업 태그와 대략적인 작업 요약이 들어가 있다.
    - 작업태그: 기능구현(feature), 버그수정(fix) …
- 내용
  - 작업할 브랜치의 To-Do 등이 들어간다.
- Assignees
  - 이슈를 작업할 담당자/작업자
- Labels
  - 작업 태그
- Projects, Milestone
  - 조금 더 큰 단위의 작업 내용을 적는 부분
- Development
  - 이슈와 연결된 브랜치/PR을 연결하는 부분

### 2. Pull Request

- 이슈 생성 후 브랜치를 만들고 작업을 진행했다면 작업 내용을 main 브랜치에 반영해야 한다. → 이때 하는것이 PR
- Issue와 동일하게 크게 제목, 내용, Reviewers, Assignees, Labels, Projects, Milestone, Development로 나눌 수 있다. (팀 내 컨벤션에 따라 달라짐)
- PR에서 공동 작업자들의 코드리뷰(Code Review)를 한다.
  - Reviewers 가 코드 리뷰를 진행함.
